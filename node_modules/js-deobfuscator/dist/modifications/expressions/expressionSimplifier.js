"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const modification_1 = __importDefault(require("../../modification"));
const Shift = __importStar(require("shift-ast"));
const traverse_1 = require("../../helpers/traverse");
const traversalHelper_1 = __importDefault(require("../../helpers/traversalHelper"));
class ExpressionSimplifier extends modification_1.default {
    /**
     * Creates a new modification.
     * @param ast The AST.
     */
    constructor(ast) {
        super('Simplify Expressions', ast);
        this.types = new Set(['BinaryExpression', 'UnaryExpression']);
    }
    /**
     * Executes the modification.
     */
    execute() {
        this.simplifyExpressions();
    }
    /**
     * Simplifies all binary and unary expressions.
     */
    simplifyExpressions() {
        const self = this;
        traverse_1.traverse(this.ast, {
            enter(node, parent) {
                if (self.types.has(node.type)) {
                    const replacement = self.simplifyExpression(node);
                    if (replacement != node) {
                        traversalHelper_1.default.replaceNode(parent, node, replacement);
                    }
                }
            }
        });
    }
    /**
     * Attempts to simplify an expression node.
     * @param expression The expression node.
     */
    simplifyExpression(expression) {
        switch (expression.type) {
            case 'BinaryExpression':
                return this.simplifyBinaryExpression(expression);
            case 'UnaryExpression':
                return this.simplifyUnaryExpression(expression);
            default:
                return expression;
        }
    }
    /**
     * Attempts to simplify a binary expression node.
     * @param expression The binary expression node.
     */
    simplifyBinaryExpression(expression) {
        const left = this.simplifyExpression(expression.left);
        const right = this.simplifyExpression(expression.right);
        const leftValue = this.getExpressionValueAsString(left);
        const rightValue = this.getExpressionValueAsString(right);
        if (leftValue != null && rightValue != null) {
            const code = `${leftValue} ${expression.operator} ${rightValue}`;
            const simplified = this.evalCodeToExpression(code);
            return simplified != null ? simplified : expression;
        }
        else {
            return expression;
        }
    }
    /**
     * Attempts to simplify a unary expression node.
     * @param expression The unary expression node.
     */
    simplifyUnaryExpression(expression) {
        expression.operand = this.simplifyExpression(expression.operand);
        const code = this.getExpressionValueAsString(expression);
        if (code != null) {
            const simplified = this.evalCodeToExpression(code);
            return simplified != null ? simplified : expression;
        }
        else {
            return expression;
        }
    }
    /**
     * Returns the value of a node as a string, null if not possible.
     * @param expression The expression node.
     */
    getExpressionValueAsString(expression) {
        switch (expression.type) {
            case 'LiteralStringExpression':
                const value = expression.value
                    .replace(/"/g, '\\"')
                    .replace(/\n/g, '\\n')
                    .replace(/\r/g, '\\r');
                return `"${value}"`;
            case 'LiteralNumericExpression':
            case 'LiteralBooleanExpression':
                return expression.value.toString();
            case 'ArrayExpression':
                if (expression.elements.length == 0) {
                    return '[]';
                }
                else if (expression.elements.every(e => !e || e.type.startsWith('Literal'))) {
                    let content = '';
                    for (let i = 0; i < expression.elements.length; i++) {
                        if (expression.elements[i]) {
                            content += `${this.getExpressionValueAsString(expression.elements[i])},`;
                        }
                        else {
                            content += ',';
                        }
                    }
                    return `[${content.substring(0, content.length - 1)}]`;
                }
                else {
                    return null;
                }
            case 'ObjectExpression':
                if (expression.properties.length == 0) {
                    expression.properties;
                    return '[]';
                }
                else {
                    return null;
                }
            case 'UnaryExpression':
                const operand = this.getExpressionValueAsString(expression.operand);
                return operand != null ? `${expression.operator} ${operand}` : null;
            default:
                return null;
        }
    }
    /**
     * Evaluates a given piece of code and converts the result to an
     * expression node if possible.
     * @param code The code to be evaluated.
     */
    evalCodeToExpression(code) {
        let value;
        try {
            value = eval(code);
        }
        catch (err) {
            return null;
        }
        switch (typeof value) {
            case 'string':
                return new Shift.LiteralStringExpression({
                    value: value
                });
            case 'number':
                return new Shift.LiteralNumericExpression({
                    value: value
                });
            case 'boolean':
                return new Shift.LiteralBooleanExpression({
                    value: value
                });
            default:
                return null;
        }
    }
    isSimpleArray(array) {
        return array.elements.every(e => !e || e.type.startsWith('Literal'));
    }
}
exports.default = ExpressionSimplifier;

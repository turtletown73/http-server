"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const modification_1 = __importDefault(require("../../modification"));
const traverse_1 = require("../../helpers/traverse");
const traversalHelper_1 = __importDefault(require("../../helpers/traversalHelper"));
const scope_1 = __importDefault(require("./scope"));
const proxyFunction_1 = __importDefault(require("./proxyFunction"));
const graph_1 = __importDefault(require("../../graph/graph"));
const node_1 = __importDefault(require("../../graph/node"));
const edge_1 = __importDefault(require("../../graph/edge"));
class ProxyRemover extends modification_1.default {
    /**
     * Creates a new modification.
     * @param ast The AST.
     * @param removeProxyFunctions Whether the functions should be removed.
     */
    constructor(ast, removeProxyFunctions) {
        super('Remove Proxy Functions', ast);
        this.scopeTypes = new Set(['Block', 'FunctionBody']);
        this.proxyExpressionTypes = new Set([
            'CallExpression',
            'BinaryExpression',
            'UnaryExpression',
            'ComputedMemberExpression',
            'IdentifierExpression'
        ]);
        this.shouldRemoveProxyFunctions = removeProxyFunctions;
        this.globalScope = new scope_1.default(this.ast);
        this.proxyFunctions = [];
        this.proxyFunctionNames = new Set();
        this.cyclicProxyFunctionIds = new Set();
        this.graph = new graph_1.default();
    }
    /**
     * Executes the modification.
     */
    execute() {
        this.findProxyFunctions();
        this.findAliases();
        this.findCycles();
        this.replaceProxyFunctionUsages(this.ast, this.globalScope);
        if (this.shouldRemoveProxyFunctions) {
            this.removeProxyFunctions(this.globalScope);
        }
    }
    /**
     * Finds all proxy functions and records them in the according scope.
     */
    findProxyFunctions() {
        const self = this;
        let scope = this.globalScope;
        traverse_1.traverse(this.ast, {
            enter(node, parent) {
                if (self.scopeTypes.has(node.type)) {
                    scope = new scope_1.default(node, scope);
                }
                let proxyFunction;
                if (self.isProxyFunctionDeclaration(node)) {
                    const name = node.name.name;
                    const params = node.params.items;
                    const expression = node.body.statements[0].expression;
                    proxyFunction = new proxyFunction_1.default(node, parent, scope, name, params, expression);
                }
                else if (self.isProxyFunctionExpressionDeclaration(node)) {
                    const name = node.binding.name;
                    const params = node.init.params.items;
                    const expression = node.init.body.statements[0].expression;
                    proxyFunction = new proxyFunction_1.default(node, parent, scope, name, params, expression);
                }
                else {
                    return;
                }
                scope.addProxyFunction(proxyFunction);
                self.proxyFunctions.push(proxyFunction);
                self.graph.addNode(new node_1.default(proxyFunction.id));
                if (!self.proxyFunctionNames.has(proxyFunction.name)) {
                    self.proxyFunctionNames.add(proxyFunction.name);
                }
            },
            leave(node) {
                if (node == scope.node && scope.parent) {
                    scope = scope.parent;
                }
            }
        });
    }
    /**
     * Finds aliases for proxy functions.
     */
    findAliases() {
        const self = this;
        let scope = this.globalScope;
        traverse_1.traverse(this.ast, {
            enter(node, parent) {
                if (self.scopeTypes.has(node.type)) {
                    scope = scope.children.get(node);
                }
                if (self.isVariableReassignment(node)) {
                    const name = node.init.name;
                    if (self.proxyFunctionNames.has(name)) {
                        const newName = node.binding.name;
                        const proxyFunction = scope.findProxyFunction(name);
                        if (proxyFunction) {
                            scope.addAlias(proxyFunction, newName);
                            traversalHelper_1.default.removeNode(parent, node);
                            if (!self.proxyFunctionNames.has(newName)) {
                                self.proxyFunctionNames.add(newName);
                            }
                        }
                    }
                }
            },
            leave(node) {
                if (node == scope.node && scope.parent) {
                    scope = scope.parent;
                }
            }
        });
    }
    /**
     * Finds cycles in the proxy function graph and excludes those
     * proxy functions from replacing.
     */
    findCycles() {
        const self = this;
        for (const proxyFunction of this.proxyFunctions) {
            const thisNode = this.graph.findNode(proxyFunction.id);
            let scope = proxyFunction.scope;
            traverse_1.traverse(proxyFunction.expression, {
                enter(node) {
                    if (self.scopeTypes.has(node.type)) {
                        scope = scope.children.get(node);
                    }
                    if (self.isFunctionCall(node)) {
                        const calleeName = node.callee.name;
                        if (self.proxyFunctionNames.has(calleeName)) {
                            const otherProxyFunction = scope.findProxyFunction(calleeName);
                            if (otherProxyFunction) {
                                const otherNode = self.graph.findNode(otherProxyFunction.id);
                                if (!self.graph.hasEdge(`${thisNode.id} -> ${otherNode.id}`)) {
                                    self.graph.addEdge(new edge_1.default(thisNode, otherNode));
                                }
                            }
                        }
                    }
                },
                leave(node) {
                    if (node == scope.node && scope.parent) {
                        scope = scope.parent;
                    }
                }
            });
        }
        const seenNodes = new Set();
        for (const node of this.graph.nodes) {
            this.searchBranch(node, seenNodes);
        }
    }
    /**
     * Searches for cycles within a branch.
     * @param node The current node.
     * @param seenNodes The set of all previously seen nodes.
     * @param branch The nodes in the current branch.
     */
    searchBranch(node, seenNodes, branch) {
        if (seenNodes.has(node)) {
            return;
        }
        seenNodes.add(node);
        branch !== null && branch !== void 0 ? branch : (branch = new Set());
        branch.add(node);
        for (const edge of node.outgoingEdges) {
            const target = edge.target;
            if (branch.has(target)) {
                // cycle found
                this.cyclicProxyFunctionIds.add(target.id);
                for (const node of branch) {
                    this.cyclicProxyFunctionIds.add(node.id);
                }
            }
            else {
                this.searchBranch(target, seenNodes, branch);
            }
        }
    }
    /**
     * Replaces all usages of proxy functions in a given node.
     * @param node The node to replace usages in.
     * @param startScope The scope of the node.
     */
    replaceProxyFunctionUsages(node, scope) {
        const self = this;
        let replacedNode = node;
        traverse_1.traverse(node, {
            enter(node, parent) {
                if (self.scopeTypes.has(node.type)) {
                    const sc = scope.children.get(node);
                    if (!sc) {
                        throw new Error(`Failed to find scope for node ${node.type}`);
                    }
                    scope = sc;
                }
                else if (self.isFunctionCall(node)) {
                    const name = node.callee.name;
                    if (self.proxyFunctionNames.has(name)) {
                        const proxyFunction = scope.findProxyFunction(name);
                        if (proxyFunction && !self.cyclicProxyFunctionIds.has(proxyFunction.id)) {
                            const args = node.arguments;
                            let replacement = proxyFunction.getReplacement(args);
                            replacement = self.replaceProxyFunctionUsages(replacement, proxyFunction.scope);
                            if (parent) {
                                traversalHelper_1.default.replaceNode(parent, node, replacement);
                            }
                            else {
                                replacedNode = replacement;
                            }
                        }
                    }
                }
            },
            leave(node) {
                if (node == scope.node && scope.parent) {
                    scope = scope.parent;
                }
            }
        });
        return replacedNode;
    }
    /**
     * Removes all proxy functions from a scope and its children.
     * @param scope The scope to remove proxy functions from.
     */
    removeProxyFunctions(scope) {
        for (const [_, proxyFunction] of scope.proxyFunctions) {
            if (!this.cyclicProxyFunctionIds.has(proxyFunction.id)) {
                traversalHelper_1.default.removeNode(proxyFunction.parentNode, proxyFunction.node);
            }
        }
        for (const [_, child] of scope.children) {
            this.removeProxyFunctions(child);
        }
    }
    /**
     * Returns whether a node is a proxy function declaration.
     * @param node The AST node.
     */
    isProxyFunctionDeclaration(node) {
        if (node.type == 'FunctionDeclaration' &&
            node.body.statements.length == 1 &&
            node.body.statements[0].type == 'ReturnStatement' &&
            node.body.statements[0].expression != null &&
            (this.proxyExpressionTypes.has(node.body.statements[0].expression.type) ||
                node.body.statements[0].expression.type.startsWith('Literal')) &&
            node.params.items.find(p => p.type != 'BindingIdentifier') == undefined) {
            const self = this;
            let hasScopeNode = false;
            traverse_1.traverse(node.body.statements[0].expression, {
                enter(node) {
                    if (self.scopeTypes.has(node.type)) {
                        hasScopeNode = true;
                    }
                }
            });
            return !hasScopeNode;
        }
        else {
            return false;
        }
    }
    /**
     * Returns whether a node is a proxy function expression variable
     * declaration.
     * @param node The AST node.
     */
    isProxyFunctionExpressionDeclaration(node) {
        if (node.type == 'VariableDeclarator' &&
            node.binding.type == 'BindingIdentifier' &&
            node.init != null &&
            node.init.type == 'FunctionExpression' &&
            node.init.body.statements.length == 1 &&
            node.init.body.statements[0].type == 'ReturnStatement' &&
            node.init.body.statements[0].expression != null &&
            (this.proxyExpressionTypes.has(node.init.body.statements[0].expression.type) ||
                node.init.body.statements[0].expression.type.startsWith('Literal'))) {
            const self = this;
            let hasScopeNode = false;
            traverse_1.traverse(node.init.body.statements[0].expression, {
                enter(node) {
                    if (self.scopeTypes.has(node.type)) {
                        hasScopeNode = true;
                    }
                }
            });
            return !hasScopeNode;
        }
        else {
            return false;
        }
    }
    /**
     * Returns whether a node is a variable reassignment.
     * @param node The AST node.
     * @returns Whether.
     */
    isVariableReassignment(node) {
        return (node.type == 'VariableDeclarator' &&
            node.binding.type == 'BindingIdentifier' &&
            node.init != null &&
            node.init.type == 'IdentifierExpression');
    }
    /**
     * Returns whether a node is a function call.
     * @param node The AST node.
     */
    isFunctionCall(node) {
        return node.type == 'CallExpression' && node.callee.type == 'IdentifierExpression';
    }
}
exports.default = ProxyRemover;
